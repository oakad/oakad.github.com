

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Language for system programing, or C is not going to stay here forever &mdash; Alex Dubov&#39;s assorted articles</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="Alex Dubov&#39;s assorted articles" href="index.html" />
    <link rel="up" title="Useful components for the prosperous future" href="index-ucpf.html" />
    <link rel="prev" title="Windowing system of the future in the mirror of the present" href="jx.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="jx.html" title="Windowing system of the future in the mirror of the present"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Alex Dubov&#39;s assorted articles</a> &raquo;</li>
          <li><a href="index-ucpf.html" accesskey="U">Useful components for the prosperous future</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="language-for-system-programing-or-c-is-not-going-to-stay-here-forever">
<h1>Language for system programing, or C is not going to stay here forever<a class="headerlink" href="#language-for-system-programing-or-c-is-not-going-to-stay-here-forever" title="Permalink to this headline">¶</a></h1>
<p><em>This article is still being written.</em></p>
<p>The new language, being described here, is to be called Chi.</p>
<div class="section" id="basic-syntax-and-concepts">
<h2>Basic syntax and concepts<a class="headerlink" href="#basic-syntax-and-concepts" title="Permalink to this headline">¶</a></h2>
<p>Chi makes extensive use of type patterns. In fact, every type is a pattern,
analogous to C++ template. Otherwise than this, the language is strictly
procedural, and has no special provisions for objects and related concepts. The
underlaying machine model is expected to closely match the physical machine
(C style) and rely on OS provided libraries to the extent possible.</p>
<div class="section" id="extended-hello-world">
<h3>Extended &#8220;Hello World&#8221;<a class="headerlink" href="#extended-hello-world" title="Permalink to this headline">¶</a></h3>
<p>A slightly more elaborate version of &#8220;Hello World&#8221; application can demonstrate
some abilities of the Chi programming language.</p>
<div class="highlight-none"><div class="highlight"><pre>// Declaration of the C fprintf like function
[ (file* fd, (type(T) v | type(file* fd -&gt; void) f) ...) -&gt; int ]
fprintf;

[ (int argc, char*[...] argv) -&gt; int ] main = {
  for (int pos = 0; pos &lt;  argc; pos += 1)
    fprintf(stdout, &quot;arg &quot;, argc, &quot;: &quot;, argv(pos), &quot;\n&quot;);

  return 0;
}
</pre></div>
</div>
</div>
<div class="section" id="basics">
<h3>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h3>
<p>Statement syntax is generally inherited from C:</p>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">statement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="nv">typedecl</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="s">&#39;;&#39;</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="type-decalarations">
<h3>Type decalarations<a class="headerlink" href="#type-decalarations" title="Permalink to this headline">¶</a></h3>
<div class="highlight-antlr"><div class="highlight"><pre><span class="nl">typedecl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">typename</span><span class="o">?</span><span class="w"> </span><span class="s">&#39;[&#39;</span><span class="w"> </span><span class="nv">typedef</span><span class="w"> </span><span class="s">&#39;]&#39;</span><span class="w"> </span><span class="nv">varlist</span><span class="o">?</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="nl">varlist</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">vardef</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w"> </span><span class="nv">vardef</span><span class="w"> </span><span class="o">)*</span><span class="w"> </span><span class="p">;</span><span class="w"></span>

<span class="nl">vardef</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">varname</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="s">&#39;[&#39;</span><span class="w"> </span><span class="nv">varattr</span><span class="o">+</span><span class="w"> </span><span class="s">&#39;]&#39;</span><span class="w"> </span><span class="o">)?</span><span class="w"> </span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>It so happens, that both in development of new programing languages, as well
as in development of new operating systems, the issue of IO and interaction
with machine hardware in general is often neglected. Fancy abstractions,
breath-taking in their elegance or, to the contrary, excessive simplification
of language constructs and idioms draw almost all of the attention of language
designers. Yet, apart from focusing on the logical and psychological aspects
of software engineering, it seems worthwhile to pay some attention to the
real world machines and create a language which will target the hard task of
direct hardware management.</p>
<p>No wonder that C programing language remains a mainstay of system programing for
nearly 40 years already. There simply was no worthy successor to take on the
task. One of the honourable reasons for this, is of course a considerable
wisdom (if not genius) of its original designers, who were able to clearly
identify the goals and needs of a basic system language. C++, which aimed to
become such a successor, had essentially failed in this task. D programing
language (posed as a new alternative to C++) had managed to do the same, even
before gaining any sort of widespread adoption</p>
<p>Here I would like to point out, that, to my opinion, modern C++ is the most
powerful and versatile language in existence, and well written programs in it
are often exceptionally elegant. Yet, to be used in a system role it must be
necessarily reduced to a subset of its features and, therefore, loses a lot of
its innate flexibility.</p>
</div>
</div>
<div class="section" id="what-is-really-needed-from-the-system-programing-language">
<h2>What is really needed from the system programing language?<a class="headerlink" href="#what-is-really-needed-from-the-system-programing-language" title="Permalink to this headline">¶</a></h2>
<p>Every good design must build on a solid conceptual foundation. For a system
language, the main law by which it should behave can be stated as <em>&#8220;no run-time
magic&#8221;</em>. The exact behaviour of program in run-time should be more or less
obvious from the inspection of source code.</p>
<p>We can identify two major sorts of &#8220;magic&#8221;: storage domain and time domain one.
Examples of storage domain magic include things like C++ vtables or,
generally, object/value storage layout as (not)defined by most modern high-level
languages. Time domain magic is represented by rather non-trivial run-time
functionality needed to make constructors, destructors (if present in the
language) and exceptions work. Garbage collectors also belong to the category
of time domain magical things, and in some more advanced cases, this epithet is
not even slightly exaggerating.</p>
<p>On the other hand, there are plenty of compile time constructs that new
language can and should support. Functional classes (interfaces), type
inference, patterns (or templates), name spaces - all these allow development
of most complicated programs without the need to rely on any complicated and
non-obvious run-time requirements. Partial application and closures are also
a necessity, to the extent possible (the limitations are those imposed by
stack based activation record mechanism, as apparent in C++ implementation
of this feature).</p>
<p>Additional commonly neglected aspect is the ability of the language
infrastructure to control information transfer between development and run-time
environments. Size of binary programs and their respective environments matters
even in our days of abundant memory capacities (because smaller size invariably
means higher density, which is a very valuable and difficult to conserve
physical quality). There also exists a necessity to strictly isolate the
interface definitions from their actual implementations, commonly neglected in
modern programing language design, where implementation code often acts as a
sole interface defining entity.</p>
<p>In this article I will endeavour to collect useful thoughts about a somewhat
different programing language, I shall call <em>Chi</em> (like the X-shaped Greek
letter). I do not aim for similarity or code level compatibility with C, but
want to try and refine the ideas, which make C and C++ languages to be of
such incredible use in low level application development.</p>
<p>As opposed to C++, I do not want to retain any features of so called classical
object-orientedness, opting instead for functional classes approach. After all,
real-world objects do not have intrinsic notion of built-in operations, unlike
the software ones. Common chair can be moved around the room not because of
some &#8220;inherited method&#8221;, but only because somebody wishes to move it, it isn&#8217;t
screwed down to the floor and weights only couple of kilogrammes. Those listed
properties can be set together as a functional class applicable to the
chair-like values (and many other things), thus providing a useful alternative
to C++ style objects.</p>
<div class="section" id="on-limited-usefulness-of-exceptions">
<h3>On limited usefulness of exceptions<a class="headerlink" href="#on-limited-usefulness-of-exceptions" title="Permalink to this headline">¶</a></h3>
<p>Venerable and useful <tt class="docutils literal"><span class="pre">goto</span></tt> statement (unconditional transfer of control) had
long been seen as an embodiment of evil of some sort, which must be eradicated
in any cost. Curiously enough, in modern programing languages alternatives
offered often end up being similar in their features to the
<a class="reference external" href="http://en.wikipedia.org/wiki/Comefrom">comefrom</a> construct, which is even
worse. One notable example of such misuse are labelled statements in Java,
whereupon the label is specified at the beginning of the block, while control
is most often transferred past its end. Exceptions happen to suffer a similar
ill fate.</p>
<p>It must be noted, that exceptions come in two rather distinct varieties.
Borrowing the Java terminology, they can be either checked or unchecked, the
difference being that any function desiring to throw checked exceptions must
explicitly list them in its declaration. No such restriction applies to
unchecked exceptions, which can simply pop-up from elsewhere at any time.</p>
<p>It is immediately clear, that checked exceptions are not true exceptions at
all, so to say. Rather they can be treated as alternative return types for
a given function. Discriminated unions were long neglected by mainstream
programing languages, yet checked exceptions essentially result in function
returning such an union of its normal return type with some additional exception
types listed in the declaration. There appears to be no saving in amount of
typing or clarity of the resulting code when using checked exceptions versus
Haskell-style Maybe return types or plain C pointers employing a similar
adaptation (pointers can seldom access their full numeric range worth of
storage, so an arithmetic sub-range can be set within possible pointer values
to indicate various cases of failure).</p>
<p>Unchecked exceptions present a more interesting problem, however. They can be
emitted by functions which don&#8217;t have a user accessible return value at all,
object constructors and destructors of C++ being a prominent example. They also
serve to provide a variety of non-local return from a throwing function,
delivering their value somewhere deep in the call stack, instead of a simple
return to the caller. To better assess a usefulness of these features to a
system level language, a short enumeration may come handy:</p>
<ol class="arabic simple">
<li>Throwing exceptions from constructors requires considerable caution in
non-garbage collected languages, often resulting in memory and resource
leaks. Considerable local error checking is almost inevitable in non-trivial
cases to the extent, that its easier to just normally finish construction of
semantically invalid object with an additional post-construction check for
integrity (very common pattern in C++ programs).</li>
<li>Throwing exceptions from destructors appears to be an exercise in futility.
Fortunately, its almost never done or needed.</li>
<li>Non-local error handling, or throwing exceptions from arbitrary places in the
program is advocated on the basis that exceptional conditions are not
supposed to be recovered from. Yet, high reliability software systems do
commonly have an ability to recover from almost all varieties of errors
they may encounter, short of physical hardware damage. Under the assumption,
that errors are not too rare and must be recovered from as quickly as
possible, local error handling (C style) appears to be more useful approach.</li>
</ol>
<p>Nevertheless, in past years, exceptions became a standard programing construct.
It seems beneficial to implement them in Chi as well, albeit in such a fashion
as to afford easy switching to exception-free code. The most obvious way to
do so is to abolish the need for customary <tt class="docutils literal"><span class="pre">try</span></tt> - <tt class="docutils literal"><span class="pre">catch</span></tt> construct.
Instead, compiler will implicitely promote any scope immediately followed by
one or more <tt class="docutils literal"><span class="pre">catch</span></tt> statements to become exception catching. In case,
compiler is instructed to disable exceptions, such <tt class="docutils literal"><span class="pre">catch</span></tt> statements can
turn into noops, optionally rising compilation warnings or errors.</p>
<p>Chi programing style guideline is not expected to emphasize the of exceptions
for error recovery (unlike many other languages).</p>
</div>
</div>
<div class="section" id="type-system-and-basic-data-structures">
<h2>Type system and basic data structures<a class="headerlink" href="#type-system-and-basic-data-structures" title="Permalink to this headline">¶</a></h2>
<p>On the most basic level Chi should possess exactly one data type, which I shall
call <tt class="docutils literal"><span class="pre">byte</span> <span class="pre">type</span></tt>. This data type represents smallest individually accessible
physical storage location and has a size of 1. Byte type is also a precursor
to all numeric types and has all the traits of range limited integer.</p>
<p>Byte type values can be composed into combinations of three basic data
structures, all customisable with type patterns:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">Array</span></tt> densely packs set number of values in consecutive locations of the
physical storage. Short array of bytes can be used to represent all the basic
numeric types, apart from other useful things.</li>
<li><tt class="docutils literal"><span class="pre">Tuple</span></tt> (or structure) defines a value composed of several differently
typed values, possibly named. It also affects name resolution rules in
functions taking it as argument. Special forms of tuples are nameless
tuples, which bind their member names directly into an enclosing scope and
extensible tuples, which can act as extentions to other values.</li>
<li><tt class="docutils literal"><span class="pre">Variant</span></tt> (or discriminating union) represents a value which can be of
one of the data types defined in the variant&#8217;s declaration. Unlike C unions,
it can not be assigned as one data type, then taken as another. Rather, it
&#8220;remembers&#8221; the type it was assigned to last time.</li>
</ol>
<p>Additional important data type present at the Chi&#8217;s basic abstraction layer
is functional closure, which doubles as a general function type.</p>
<div class="section" id="functional-classes">
<h3>Functional classes<a class="headerlink" href="#functional-classes" title="Permalink to this headline">¶</a></h3>
<p>Any type can be made conformant with one or more functional classes, which
define a set of operations, applicable to the given class. This is similar
to the Haskell classes or Java interfaces.</p>
<p>In particular, pointers and references are really types which can be passed
as arguments to appropriate dereferencing operator. For couple of integer types
this dereferencing operator is defined by the compiler built-in instances (to
the tune of generic <tt class="docutils literal"><span class="pre">addressof</span></tt> operator).</p>
</div>
<div class="section" id="type-attributes">
<h3>Type attributes<a class="headerlink" href="#type-attributes" title="Permalink to this headline">¶</a></h3>
<p>Any type can have a set of associated attributes, controlling code generation
and run-time behavior of the corresponding value. Same type with distinct
attributes can be seen as belonging to the same family and Chi should provide
means to automate promotion and conversion of such related types.</p>
<p>Of attributes, those appear to be definitely necessary:
#. <tt class="docutils literal"><span class="pre">any</span></tt> (stripping of all attributes for use in type patern).
#. <tt class="docutils literal"><span class="pre">const</span></tt> (read-only values).
#. <tt class="docutils literal"><span class="pre">volatile</span></tt> (restricted optimization).
#. <tt class="docutils literal"><span class="pre">packed</span></tt> (dense storage utilization).
#. <tt class="docutils literal"><span class="pre">atomic</span></tt> (similarly to Java <tt class="docutils literal"><span class="pre">synchronized</span></tt>, extends type with
synchronisztion constructs or generates appropriate code for it).</p>
</div>
<div class="section" id="type-calculations">
<h3>Type calculations<a class="headerlink" href="#type-calculations" title="Permalink to this headline">¶</a></h3>
<p>Chi compiler will provide both the ability to synthesize arbitrary types out
of type patterns by evaluating special programs, taking type names as arguments.
Results of the above evaluations will represent composite types with specific
storage requirements, which can be instantiated and used by user code.</p>
</div>
</div>
<div class="section" id="compilation-process">
<h2>Compilation process<a class="headerlink" href="#compilation-process" title="Permalink to this headline">¶</a></h2>
<p>Considerable deployment flexibility attainable by using C/C++ in software
development stems from the rather unusual three stage compilation process
employed by the languages. Only the middle stage of the process is controlled by
the core language syntactic constructs. The other two are managed by the special
mini-languages introduced by the supporting tools. To summarise, the steps taken
to build a C application normally look like this:</p>
<ol class="arabic simple">
<li>Preprocessor inspects the source files looking for certain recognised
statements. Among those, include statements are used to pull in additional
source files, the result being a transformed C language program having no
external source level (interface) dependencies. A set of all preprocessor
statements forms a rather complete programing language on its own.
Unfortunately, in some cases, this language is not up to the task, so
additional program transformation may need to be performed by some custom
tool, before the standard preprocessor can kick in. Whether this can be
avoided in every case is debatable, but observable fact is that many large
and complex programs do rely on such multi-level preprocessing.</li>
<li>Compilation proper is performed on a transformed stand-alone source unit,
which, at this stage, can be unnecessarily large, having all its source
dependencies literally included. Object file is produced as a result,
containing all the CPU instructions for the just compiled program unit, but
still lacking means to access external run-time dependencies.</li>
<li>The set of generated object files is put together by a separate tool, called
linker, to create the desired end result (executable program or library).
Linker relies on a script in its own language and some additional user input
to examine the necessary run-time dependencies and to further transform
object files producing the final binary.</li>
</ol>
<p>Chi strives to retain the same flexibility with the important distinction of
incorporating the preprocessor into the core language, in the form of <tt class="docutils literal"><span class="pre">const</span></tt>
statements and <tt class="docutils literal"><span class="pre">macro</span></tt> construct. Any language statement resulting in an
assignment to a constant value or anonymous <tt class="docutils literal"><span class="pre">const</span></tt> qualified code blocks
must be fully evaluated by compiler, if possible, otherwise compilation error
will arise. <tt class="docutils literal"><span class="pre">macro</span></tt> construct, in turn, is a block of statements, which are
literally rewritten by compiler during the argument expansion and then copied
into the original location of macro invocation, just like the C preprocessor
function like macros. Important difference from C preprocessor, in this case,
is handling of macros by the core compiler, which retains information on their
structure and location.</p>
<p>Source level dependencies are also pulled directly by the core compiler.
Additional sources are pulled in by filesystem path, again in similarity with
C preprocessor. Each distinctive (as determined by its contents, not name)
source file pulled in is read exactly once, as the ability for multiple self
inclusion exhibited by C header file appears to be too cumbersome for practical
use. Extensive compile time evaluation abilities should compensate for this
shortcoming.</p>
<p>Besides normal source file, binary object files can also be specified as
dependencies on the source level. It is conceived, that compiler should be
able to extract necessary information directly from the extended symbol table
information optionally present in the binaries, to reduce source level clutter
in programs with extensive third-party dependencies. For example, interface
description in the source file may contain only generic type patterns, while
information on specific pattern instantiations will be read directly from the
link library (or its detached symbol file).</p>
<p>In some cases it is handy not to rely on explicit source import statements at
all. For such environments, Chi compiler will have an ability to use a namespace
to file name mapping database, such that any referenced namespace will pull in
the necessary source dependencies and push the necessary updates back to the
database.</p>
<p>Considering the above considerations, Chi compilation will occur as a single
stage process, collapsing the traditional C compilation stages into a one
heavy-weight stage and abolishing the difference between include and library
file search paths. Each compilation unit will be processed into an
incrementally linked binary, possibly capable of being immediately loaded into
a JIT based application or further linked with other such binaries by means
of standard C linker.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Language for system programing, or C is not going to stay here forever</a><ul>
<li><a class="reference internal" href="#basic-syntax-and-concepts">Basic syntax and concepts</a><ul>
<li><a class="reference internal" href="#extended-hello-world">Extended &#8220;Hello World&#8221;</a></li>
<li><a class="reference internal" href="#basics">Basics</a></li>
<li><a class="reference internal" href="#type-decalarations">Type decalarations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#what-is-really-needed-from-the-system-programing-language">What is really needed from the system programing language?</a><ul>
<li><a class="reference internal" href="#on-limited-usefulness-of-exceptions">On limited usefulness of exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-system-and-basic-data-structures">Type system and basic data structures</a><ul>
<li><a class="reference internal" href="#functional-classes">Functional classes</a></li>
<li><a class="reference internal" href="#type-attributes">Type attributes</a></li>
<li><a class="reference internal" href="#type-calculations">Type calculations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compilation-process">Compilation process</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="jx.html"
                        title="previous chapter">Windowing system of the future in the mirror of the present</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/syslang.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="jx.html" title="Windowing system of the future in the mirror of the present"
             >previous</a> |</li>
        <li><a href="index.html">Alex Dubov&#39;s assorted articles</a> &raquo;</li>
          <li><a href="index-ucpf.html" >Useful components for the prosperous future</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; <a href="copyright.html">Copyright</a> 2010 - 2012, Alex Dubov &lt;oakad@yahoo.com&gt;.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>